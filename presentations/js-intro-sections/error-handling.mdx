import { SlideLayout, Image, FlexBox, Box, Notes } from 'spectacle'
import { CodeDisplay, File, Tests } from '../components/CodeDisplayWithSlideTracking'

<SlideLayout.Full>
## ‚ö†Ô∏è Error Handling

Building Robust JavaScript Applications

<Notes>
Error Handling is one of the most critical topics for building production-ready applications. Today we'll cover everything from basic try/catch blocks to creating sophisticated error handling systems.

Error handling is often overlooked by beginners, but it's what separates amateur code from professional applications. In our habit tracker context, proper error handling means the difference between an app that crashes when users enter unexpected data and one that gracefully guides them through corrections.

We'll start with the fundamentals and build up to advanced patterns that you'll use in real-world applications. Pay special attention to the examples - they're all designed around scenarios you'll encounter when building our habit tracking application.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Making Your Code Resilient

- Understanding errors in JavaScript
- Try/catch/finally blocks
- Creating custom error types
- Error recovery strategies

<Notes>
This section is all about making your code resilient - meaning it can handle unexpected situations gracefully without crashing or losing user data.

First, we'll understand what errors actually are in JavaScript and why they occur. Many students think errors are bad, but they're actually helpful signals that something needs attention.

Then we'll dive deep into try/catch/finally blocks - the fundamental error handling mechanism in JavaScript. The 'finally' block is often misunderstood, so we'll spend time on when and why to use it.

Custom error types are where things get really powerful. Instead of generic Error objects, we'll create specific error classes that make debugging easier and allow for targeted error handling.

Finally, error recovery strategies - this is about building applications that can adapt when things go wrong, providing fallback behaviors and maintaining functionality even when some features fail.

Think about your habit tracker - what happens if the database is unavailable? A resilient app saves to local storage instead. What if the user enters invalid data? A well-designed app guides them to fix it rather than just crashing.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Why Error Handling Matters

Common errors in applications:
- Invalid user input
- Network failures
- Storage quota exceeded
- Missing or corrupted data
- API rate limits

<Notes>
Let's talk about why error handling is absolutely critical. These aren't theoretical problems - these are real issues that every application faces in production.

Invalid user input is probably the most common error you'll encounter. Users will enter text where you expect numbers, leave required fields empty, or input data in unexpected formats. In our habit tracker, someone might try to create a habit with an empty name or set a target of negative days.

Network failures happen constantly - users lose WiFi, servers go down, or requests timeout. Your habit tracker needs to handle these gracefully, perhaps by saving data locally until the connection is restored.

Storage quota exceeded is increasingly common as web apps store more data locally. Browser storage limits vary, and users on older devices might hit these limits quickly.

Missing or corrupted data can occur due to browser crashes, power failures, or storage corruption. Your app should detect this and either recover or guide the user through data restoration.

API rate limits are a fact of life when integrating with third-party services. If your habit tracker syncs with a fitness API, you need to handle cases where you've made too many requests.

Without proper error handling, any of these scenarios can crash your application and frustrate users. With good error handling, these become minor inconveniences that your app handles smoothly.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Without vs With Error Handling

```javascript
// Without error handling
const data = JSON.parse(userInput); // üí• Crash!

// With error handling
try {
  const data = JSON.parse(userInput);
} catch (error) {
  showMessage("Invalid data format");
}
```

<Notes>
This simple example perfectly illustrates the difference between fragile and robust code. Let's break this down:

Without error handling, if a user provides malformed JSON - maybe they forgot a closing brace or used single quotes instead of double quotes - JSON.parse() throws an exception that crashes your entire application. The user sees a cryptic error message or, worse, a blank screen.

With error handling, the same malformed input is caught gracefully. Instead of crashing, your application shows a helpful message like "Invalid data format" and continues running. The user can correct their input and try again.

In the context of our habit tracker, imagine importing habit data from a file. Without error handling, one malformed entry crashes the entire import process. With error handling, you can skip the problematic entry, log it for review, and successfully import the rest of the data.

This is a fundamental shift in mindset - from writing code that works when everything goes right, to writing code that works even when things go wrong. The second approach is what professional developers do.

Notice that the error handling version doesn't just swallow the error - it provides feedback to the user. This is crucial: errors should be handled, not hidden.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Try/Catch/Finally Structure

<CodeDisplay >
  <File name="example.js">
    
```javascript
function saveHabitData(habitData) {
  let file = null;
  
  try {
    // Risky operations
    file = openFile('habits.json');
    const data = JSON.parse(file.read());
    data.habits.push(habitData);
    file.write(JSON.stringify(data));
    return true;
    
  } catch (error) {
    // Handle errors
    console.error('Failed to save:', error.message);
    return false;
    
  } finally {
    // Cleanup - always runs
    if (file) {
      file.close();
    }
  }
}
```
    
  </File>
</CodeDisplay>

<Notes>
Here's the complete try/catch/finally structure in action with a realistic habit tracker example. Let's walk through each section carefully:

The TRY block contains all the risky operations - opening files, parsing JSON, writing data. Any of these operations could fail for various reasons: file doesn't exist, invalid JSON, disk full, permissions issues, etc.

The CATCH block handles any errors that occur in the try block. Notice we're doing two things: logging the error for developers (console.error) and returning a meaningful result (false) to indicate failure. This allows the calling code to respond appropriately.

The FINALLY block is crucial and often misunderstood. It runs regardless of whether the try block succeeds or the catch block is executed. This makes it perfect for cleanup operations like closing files, releasing resources, or hiding loading spinners.

In this example, we declare the file variable outside the try block so it's accessible in the finally block. This is a common pattern when you need to clean up resources.

Key teaching points:
1. The finally block always runs - even if there's a return statement in try or catch
2. Use finally for cleanup, not for regular logic
3. Always handle errors meaningfully - don't just swallow them
4. Return consistent types from your functions (here, always boolean)

This pattern is fundamental to robust file operations, database connections, and any other resource management in JavaScript.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Types of JavaScript Errors

<CodeDisplay >
  <File name="errorTypes.js">
    
```javascript
// Syntax Error - caught at parse time
// const habit = { name: "Exercise" // Missing }

// Reference Error - using undefined variables
console.log(undefinedVariable); // ReferenceError

// Type Error - wrong type operations
const num = 42;
num.forEach(x => x); // TypeError: not a function

// Range Error - invalid numeric values
const arr = new Array(-1); // RangeError

// Custom Errors - your own error types
throw new Error("Habit name is required");
```
    
  </File>
</CodeDisplay>

<Notes>
Understanding the different types of errors in JavaScript is crucial for effective debugging and error handling. Let's examine each type:

SYNTAX ERRORS occur when JavaScript can't parse your code. These are caught at compile time, before your code even runs. The commented example shows a missing closing brace - this would prevent the entire file from loading. In development, your editor and tools usually catch these, but they can slip through in dynamically generated code.

REFERENCE ERRORS happen when you try to use a variable that doesn't exist. This is extremely common with typos in variable names or forgetting to import modules. In our habit tracker, this might happen if you reference 'habitData' but declared 'habitDatas'.

TYPE ERRORS occur when you try to perform an operation on a value of the wrong type. The example tries to call forEach on a number, but forEach only exists on arrays. In habit tracking, this might happen if you expect an array of habits but receive a single habit object instead.

RANGE ERRORS happen when a numeric value is outside the acceptable range. Creating an array with negative length is impossible. In our context, this might occur when calculating date ranges or habit streaks with invalid inputs.

CUSTOM ERRORS are ones you create yourself using the Error constructor or custom error classes. These are powerful for application-specific validation and business logic errors.

Each error type provides different information and might require different handling strategies. TypeError suggests a data structure problem, RangeError suggests invalid user input, and ReferenceError suggests a coding mistake.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Basic Error Handling Pattern

<CodeDisplay >
  <File name="basicPattern.js">
    
```javascript
// Basic error handling for habit tracker
try {
  const habit = createHabit(userInput);
  saveToDatabase(habit);
  updateUI(habit);
} catch (error) {
  console.error('Failed to create habit:', error.message);
  showUserError('Could not save your habit. Please try again.');
} finally {
  hideLoadingSpinner(); // Always hide spinner
}
```
    
  </File>
</CodeDisplay>

<Notes>
This is the fundamental pattern you'll use constantly in web applications. Let's break down this habit tracker example to understand each component:

The TRY block contains the complete workflow: create the habit object, save it to the database, and update the user interface. This represents the "happy path" - what should happen when everything works correctly.

Each of these operations could fail for different reasons:
- createHabit() might fail due to validation errors (missing name, invalid data)
- saveToDatabase() might fail due to network issues or server problems
- updateUI() might fail due to DOM manipulation errors or missing elements

The CATCH block handles all these potential failures with a two-pronged approach:
1. Log the technical error for developers (console.error with the actual error message)
2. Show a user-friendly message that doesn't expose technical details

This separation is crucial - developers need detailed error information for debugging, but users need simple, actionable messages.

The FINALLY block ensures the loading spinner is hidden regardless of success or failure. This is a common pattern - always clean up UI state, close connections, or release resources.

Common mistake: Don't put business logic in the finally block. It's for cleanup only.

Another key point: This pattern handles all three operations as a unit. If any step fails, the entire operation is considered failed, and the user is notified accordingly.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Throwing Custom Errors

<CodeDisplay >
  <File name="throwingErrors.js">
    
```javascript
function createHabit(data) {
  if (!data.name) {
    throw new Error('Habit name is required');
  }
  
  if (data.targetDays < 1 || data.targetDays > 365) {
    throw new RangeError('Target days must be between 1 and 365');
  }
  
  return new Habit(data);
}
```
    
  </File>
</CodeDisplay>

<Notes>
Throwing your own errors is a powerful technique for creating robust, self-documenting code. This example shows proper input validation for our habit creation function.

The first validation checks for the presence of a habit name. Using throw new Error() immediately stops execution and passes a clear message about what went wrong. This is much better than returning null or undefined, which could cause confusing errors later.

The second validation demonstrates using RangeError specifically for numeric range validation. This is more semantic than a generic Error - it tells developers exactly what type of problem occurred.

Key principles for throwing errors:

1. **Fail fast** - Validate inputs at the beginning of functions rather than halfway through processing
2. **Use descriptive messages** - "Habit name is required" is much better than "Invalid input"
3. **Choose appropriate error types** - RangeError for numeric ranges, TypeError for wrong types, generic Error for business logic
4. **Throw early, catch late** - Let errors bubble up to where they can be handled meaningfully

In the habit tracker context, this validation ensures that:
- No habits are created without names (which would break the UI)
- Target days are realistic (preventing infinite loops or negative progress)
- The application fails gracefully with clear error messages

Best practice: Always validate inputs in functions that create or modify important data structures. This prevents corrupted data from propagating through your application.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Custom Error Classes

Creating specific error types helps organize failures:

```javascript
// Base error class
class AppError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}
```

<Notes>
Custom error classes are where error handling becomes truly powerful. This is the foundation for building sophisticated error handling systems that can distinguish between different types of failures.

The AppError base class extends the built-in Error class, inheriting all its functionality while adding our own enhancements. The key line is `this.name = this.constructor.name` - this automatically sets the error name to the class name, so HabitValidationError instances will have name "HabitValidationError".

Why create a base class instead of extending Error directly?
1. **Consistency** - All your application errors share common behavior
2. **Easy identification** - You can check `if (error instanceof AppError)` to distinguish your errors from system errors
3. **Future extensibility** - You can add common properties or methods to all your errors

In our habit tracker, this becomes the foundation for:
- ValidationError for form input problems
- StorageError for database/localStorage issues
- NetworkError for API communication failures
- AuthError for authentication problems

Each can have specific properties and handling logic while sharing the common AppError foundation.

This pattern is used by major frameworks and libraries - it's a professional approach to error handling that makes debugging and maintenance much easier.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Specific Error Types

```javascript
class ValidationError extends AppError {
  constructor(message, field) {
    super(message);
    this.field = field;
  }
}

class NetworkError extends AppError {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}
```

<Notes>
Now we're building specific error types that extend our base AppError class. Each type carries additional context that helps with both debugging and user experience.

ValidationError includes a 'field' property that identifies exactly which form field caused the problem. This is incredibly useful for:
- Highlighting the problematic field in the UI
- Showing field-specific error messages
- Logging which validations fail most often

For example: `new ValidationError("Must be between 1 and 365 days", "targetDays")` tells us both what went wrong and where.

NetworkError includes a 'statusCode' property for HTTP errors. This allows different handling for different types of network failures:
- 400 errors (client mistakes) might show validation messages
- 401 errors (unauthorized) might redirect to login
- 500 errors (server problems) might trigger retry logic
- 503 errors (service unavailable) might show maintenance messages

Best practices for custom error properties:
1. **Keep them simple** - primitive values are easier to work with than complex objects
2. **Make them meaningful** - properties should help with either debugging or user experience
3. **Document them** - other developers need to know what properties are available

In our habit tracker, you might create errors like:
- `new ValidationError("Habit name cannot be empty", "name")`
- `new NetworkError("Failed to sync habits", 503)`

This structured approach makes error handling predictable and maintainable.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Benefits of Custom Errors

- Easier to handle different error types
- Can include additional context (field names, error codes)
- Improved debugging and logging
- Better user experience with specific messages

<Notes>
Let's discuss why custom errors are worth the extra effort - the benefits are substantial for any serious application.

**Easier to handle different error types**: Instead of parsing error messages or using magic strings, you can use instanceof checks. This makes your error handling code more reliable and less brittle. Compare `if (error instanceof ValidationError)` to `if (error.message.includes('validation'))`.

**Additional context**: Custom properties like field names and error codes provide structured data for both debugging and user interface improvements. Your error handling code can access error.field to highlight the correct form field, or error.statusCode to determine retry strategies.

**Improved debugging and logging**: When errors include structured data, your logs become much more useful. Instead of "Error: Something went wrong", you get "ValidationError in field 'targetDays': Must be between 1 and 365". This makes production debugging significantly easier.

**Better user experience**: With specific error types and additional context, you can provide targeted, helpful error messages. ValidationError for the 'email' field can show "Please enter a valid email address" right next to the email input, while NetworkError can show "Connection lost - changes saved locally" with a retry button.

In our habit tracker, this translates to:
- Form validation that highlights exactly which fields need attention
- Network errors that offer appropriate recovery options
- Storage errors that suggest alternative saving methods
- Clear, actionable error messages instead of cryptic technical details

The investment in custom error classes pays dividends in maintenance time saved and user satisfaction gained.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Defensive Programming: Input Validation

```javascript
function createHabit(data) {
  // Validate inputs
  if (!data || typeof data !== 'object') {
    throw new Error('Invalid habit data');
  }
  
  if (!data.name || data.name.trim() === '') {
    throw new Error('Habit name is required');
  }
  
  if (data.targetDays && (data.targetDays < 1 || data.targetDays > 365)) {
    throw new RangeError('Target days must be between 1 and 365');
  }
  
  return new Habit(data);
}
```

<Notes>
Defensive programming is about assuming that anything that can go wrong will go wrong, and coding accordingly. This function demonstrates comprehensive input validation for our habit creation process.

Let's examine each validation step:

**First check**: Ensures we received actual data and it's an object. This prevents errors if someone passes null, undefined, a string, or any other invalid type. The `typeof data !== 'object'` check catches primitive values, but remember that arrays are also objects in JavaScript - you might need additional checks for that.

**Second check**: Validates the habit name exists and isn't just whitespace. The `data.name.trim() === ''` catches names that are only spaces, tabs, or other whitespace characters. This prevents habits with effectively empty names that would break the UI.

**Third check**: Validates targetDays if it's provided. Note the `data.targetDays &&` - this makes the field optional. If it's provided, it must be within a reasonable range. The range 1-365 prevents both negative values and unrealistic goals.

Key principles demonstrated:
1. **Validate early** - Check inputs before any processing
2. **Be specific** - Each validation addresses a particular failure mode
3. **Use appropriate error types** - RangeError for numeric ranges, generic Error for business rules
4. **Handle optional fields carefully** - Check existence before validation

Common mistakes to avoid:
- Don't just check for truthy values - empty strings are falsy but might be valid in some contexts
- Don't forget to trim strings - users often accidentally add spaces
- Don't validate the same thing multiple times - be systematic

This defensive approach prevents corrupted data from entering your system and provides clear feedback when validation fails.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Error Recovery Patterns

Handle different error types specifically:
- Validation errors ‚Üí Show form feedback
- Network errors ‚Üí Retry or show offline mode
- Permission errors ‚Üí Redirect to login
- Unknown errors ‚Üí Generic fallback

<Notes>
Error recovery patterns are what separate good applications from great ones. Instead of just showing error messages, we provide pathways for users to resolve problems and continue using the application.

**Validation errors ‚Üí Show form feedback**: When users enter invalid data, highlight the problematic fields and provide specific guidance. Don't just say "Invalid input" - say "Email address must contain @ symbol" and highlight the email field. In our habit tracker, if someone enters a negative target, show "Target days must be positive" right next to that field.

**Network errors ‚Üí Retry or show offline mode**: Network failures are temporary and recoverable. Offer a "Try Again" button for failed requests. For our habit tracker, if syncing fails, save data locally and show "Saved locally - will sync when connection is restored." Consider implementing automatic retry with exponential backoff for transient failures.

**Permission errors ‚Üí Redirect to login**: Authentication failures usually mean the user's session has expired. Instead of showing a confusing error, automatically redirect to the login page or show a "Please log in again" modal. Preserve their work when possible - save form data to restore after login.

**Unknown errors ‚Üí Generic fallback**: When you encounter an error you don't recognize, provide a safe fallback experience. This might mean disabling certain features, showing cached data, or providing alternative workflows. The key is failing gracefully rather than breaking completely.

Remember: Error recovery is about maintaining user trust. Users will forgive occasional errors if your application helps them resolve the problem quickly and doesn't lose their work.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Specific Error Handling

```javascript
try {
  const result = await saveHabitToCloud(habit);
  showSuccess('Habit saved successfully!');
} catch (error) {
  if (error instanceof ValidationError) {
    showFieldError(error.field, error.message);
  } else if (error instanceof NetworkError) {
    showRetryOption('Failed to save. Try again?');
  } else {
    showGenericError('Something went wrong. Please try again.');
  }
}
```

<Notes>
This is the payoff for creating custom error classes - sophisticated error handling that provides targeted responses to different failure modes.

Let's walk through each branch of this error handling:

**Success case**: When everything works, show a clear success message. Users need confirmation that their action completed successfully. "Habit saved successfully!" is much better than no feedback at all.

**ValidationError handling**: Use the error's field property to highlight the specific problematic field and show the exact validation message. This creates a smooth user experience where form errors feel like helpful guidance rather than roadblocks.

**NetworkError handling**: Offer a retry mechanism for network failures. These are often temporary, so giving users a way to try again without losing their work is crucial. You might also save the data locally and sync it later.

**Generic error handling**: For unknown errors, provide a safe fallback that doesn't expose technical details but still acknowledges the problem. "Something went wrong" is better than a cryptic stack trace.

Best practices demonstrated:
1. **Order matters** - Check specific error types before generic ones
2. **Use instanceof** - More reliable than string matching
3. **Provide context** - Use error properties (like field) for better UX
4. **Always handle the unknown** - Have a fallback for unexpected errors

In a production habit tracker, you might also:
- Log different error types to different monitoring systems
- Implement different retry strategies based on error type
- Save user data locally when cloud sync fails
- Show different UI states (offline mode, validation errors, etc.)

This pattern scales well - you can add new error types and handling logic without changing existing code.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Fallback Behaviors

Provide alternatives when operations fail:
- Save to local storage if cloud sync fails
- Show cached data if network is unavailable
- Gracefully degrade features

<Notes>
Fallback behaviors are about designing applications that continue to function even when some components fail. This is resilience engineering - building systems that degrade gracefully rather than failing catastrophically.

**Save to local storage if cloud sync fails**: This is crucial for data integrity. If your habit tracker can't sync to the cloud, save changes locally and retry later. Show users a status like "Saved locally - will sync when connection is restored." This prevents data loss and maintains user trust. Implement a background sync process that automatically uploads local changes when connectivity returns.

**Show cached data if network is unavailable**: Rather than showing empty screens or error messages, display the last known good data. Add a subtle indicator like "Showing offline data" so users understand the state. In our habit tracker, show yesterday's habits and progress even if today's sync failed. This maintains functionality and user engagement.

**Gracefully degrade features**: When advanced features fail, fall back to basic functionality. If habit analytics can't load due to a service outage, disable the analytics section but keep habit logging working. If cloud sync is down, disable sharing features but maintain local tracking. The core functionality should never depend on optional features.

Implementation strategies:
1. **Design with offline-first mindset** - Assume network failures will happen
2. **Cache aggressively** - Store recent data locally for quick fallback
3. **Prioritize core features** - Identify which features are essential vs. nice-to-have
4. **Communicate status clearly** - Users should understand when they're in fallback mode

Examples in our habit tracker:
- Primary: Log habit completion (works offline)
- Secondary: View progress charts (cached data if offline)
- Tertiary: Social sharing (disabled if network fails)

This approach keeps users productive even when things go wrong.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Error Logging Best Practices

```javascript
function handleError(error, context) {
  // Log for developers
  console.error('Error in', context, ':', error);
  errorMonitoring.reportError(error, { context });
  
  // Show friendly message to user
  if (error instanceof ValidationError) {
    showUserMessage('Please check your input and try again.');
  } else {
    showUserMessage('We\'re experiencing technical difficulties.');
  }
}
```

<Notes>
Error logging is crucial for maintaining production applications - you need to know what's going wrong in order to fix it. This function demonstrates the dual responsibility of error handling: serving developers and users.

**Developer logging**: The console.error provides immediate debugging information during development. In production, this feeds into browser dev tools and helps with local debugging. The errorMonitoring.reportError sends structured error data to services like Sentry, LogRocket, or Bugsnag for production monitoring.

Key information to log:
- Error type and message
- Stack trace for debugging
- Context about what the user was doing
- User session information (anonymized)
- Browser and device information
- Timestamp and URL

**User communication**: The second part handles user-facing messages. Notice how different error types get different messages:
- ValidationError gets specific guidance ("check your input")
- Unknown errors get generic but reassuring messages ("technical difficulties")

Best practices for error logging:
1. **Log early and often** - Capture errors at multiple levels
2. **Include context** - What was the user trying to do?
3. **Sanitize sensitive data** - Don't log passwords or personal information
4. **Use structured logging** - JSON format makes analysis easier
5. **Set up alerts** - Get notified of critical errors immediately

In our habit tracker context:
- Log validation errors to identify common user mistakes
- Log network errors to identify service reliability issues
- Log storage errors to catch browser compatibility problems
- Track error trends to prioritize fixes

Good error logging turns production issues from mysteries into actionable bug reports.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Exercise: Custom Error Classes

<CodeDisplay >
  <File name="errorExercise.js">
    
```javascript
// Exercise: Create custom error classes for habit tracking
// TODO: Implement these error classes for our habit tracker

class HabitError extends Error {
  constructor(message) {
    super(message);
    this.name = 'HabitError';
  }
}

// TODO: Create specific error classes
class HabitValidationError extends HabitError {
  // Your code here - for invalid habit data
}

class HabitStorageError extends HabitError {
  // Your code here - for storage issues
}

class HabitSyncError extends HabitError {
  // Your code here - for sync failures
}
```
    
    
```javascript
// Solution: Complete error class hierarchy
class HabitError extends Error {
  constructor(message) {
    super(message);
    this.name = 'HabitError';
  }
}

class HabitValidationError extends HabitError {
  constructor(message, field) {
    super(message);
    this.name = 'HabitValidationError';
    this.field = field;
  }
}

class HabitStorageError extends HabitError {
  constructor(message, operation) {
    super(message);
    this.name = 'HabitStorageError';
    this.operation = operation;
  }
}

class HabitSyncError extends HabitError {
  constructor(message, statusCode) {
    super(message);
    this.name = 'HabitSyncError';
    this.statusCode = statusCode;
  }
}
```
    
  </File>
  <Tests>
    
```javascript
// Tests for Custom Error Classes
describe('Custom Error Classes', () => {
  it('should create HabitValidationError with field info', () => {
    const error = new HabitValidationError('Name is required', 'name');
    expect(error.name).to.equal('HabitValidationError');
    expect(error.field).to.equal('name');
    expect(error.message).to.equal('Name is required');
  });
  
  it('should create HabitStorageError with operation info', () => {
    const error = new HabitStorageError('Database connection failed', 'save');
    expect(error.name).to.equal('HabitStorageError');
    expect(error.operation).to.equal('save');
  });
  
  it('should create HabitSyncError with status code', () => {
    const error = new HabitSyncError('Server unavailable', 503);
    expect(error.name).to.equal('HabitSyncError');
    expect(error.statusCode).to.equal(503);
  });
});
```
    
  </Tests>
</CodeDisplay>

<Notes>
This exercise puts everything together - creating a complete error class hierarchy for our habit tracker application. Let's walk through the learning objectives and implementation details.

**Exercise Structure**: Students start with the base HabitError class and need to implement three specific error types. This teaches inheritance patterns and the importance of structured error handling.

**Base HabitError class**: Provides common functionality for all habit-related errors. The explicit `this.name = 'HabitError'` setting ensures proper error identification. All habit errors inherit from this base, making it easy to catch habit-specific errors with `instanceof HabitError`.

**HabitValidationError**: Includes a 'field' property to identify which data field caused the validation failure. This enables targeted UI feedback - highlighting specific form fields and showing relevant error messages. Usage: `new HabitValidationError('Name is required', 'name')`.

**HabitStorageError**: Includes an 'operation' property to identify what storage operation failed (save, load, delete, etc.). This helps with debugging and implementing operation-specific recovery strategies. Usage: `new HabitStorageError('Database connection failed', 'save')`.

**HabitSyncError**: Includes a 'statusCode' property for HTTP status codes when syncing with remote services. This enables different handling for different types of network failures. Usage: `new HabitSyncError('Server unavailable', 503)`.

**Teaching Points**:
1. Each error type serves a specific purpose in the application architecture
2. Additional properties provide context for both debugging and user experience
3. The inheritance hierarchy allows both specific and general error handling
4. Tests demonstrate how to verify error properties and behavior

This pattern scales well - you can add new error types (like HabitPermissionError or HabitQuotaError) without changing existing code.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Using Custom Errors

```javascript
function validateHabit(habitData) {
  if (!habitData.name || habitData.name.trim() === '') {
    throw new HabitValidationError('Habit name is required', 'name');
  }
  if (!habitData.category) {
    throw new HabitValidationError('Habit category is required', 'category');
  }
  if (habitData.targetDays && (habitData.targetDays < 1 || habitData.targetDays > 365)) {
    throw new HabitValidationError('Target days must be between 1 and 365', 'targetDays');
  }
}
```

<Notes>
Now we see our custom error classes in action! This validation function demonstrates how to use custom errors effectively to provide structured, actionable feedback.

**Specific field identification**: Each HabitValidationError includes the exact field name that failed validation. This allows the calling code to:
- Highlight the problematic form field in red
- Show the error message next to the relevant input
- Focus the user's attention on what needs to be fixed
- Track which validations fail most often for UX improvements

**Clear, actionable messages**: Instead of generic "Invalid input" messages, we provide specific guidance:
- "Habit name is required" tells the user exactly what's missing
- "Target days must be between 1 and 365" gives clear boundaries
- Messages are written for end users, not developers

**Consistent error handling**: All validation errors use the same pattern and error type, making the calling code predictable and maintainable.

Best practices demonstrated:
1. **One error per validation rule** - Don't combine multiple validation failures into one error
2. **Field-specific errors** - Always include the field name for UI targeting
3. **User-friendly messages** - Write for your users, not your debugging logs
4. **Fail fast** - Validate in order of importance, stopping at the first failure

Usage in the UI layer:
```javascript
try {
  validateHabit(formData);
} catch (error) {
  if (error instanceof HabitValidationError) {
    highlightField(error.field);
    showFieldError(error.field, error.message);
  }
}
```

This approach transforms error handling from a debugging tool into a user experience feature.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Error Handling in Practice

```javascript
function saveHabit(habitData) {
  try {
    validateHabit(habitData);
    // Save to database
    console.log('Habit saved successfully');
  } catch (error) {
    if (error instanceof HabitValidationError) {
      console.error(`Validation error in ${error.field}: ${error.message}`);
    } else if (error instanceof HabitStorageError) {
      console.error(`Storage error during ${error.operation}: ${error.message}`);
    } else {
      console.error('Unexpected error:', error.message);
    }
    throw error; // Re-throw for caller to handle
  }
}
```

<Notes>
This function demonstrates a complete error handling pattern that combines validation with storage operations, showing how custom error classes enable sophisticated error management.

**Multi-layered error handling**: The function handles errors from multiple sources:
- Validation errors from the validateHabit() call
- Storage errors from database operations (though not shown, they would be thrown by the storage layer)
- Unexpected errors from any other source

**Structured logging**: Each error type gets logged with specific context:
- Validation errors include the field name for targeted debugging
- Storage errors include the operation type to identify where failures occur
- Unknown errors get generic logging to catch unexpected issues

**Error re-throwing**: The `throw error` at the end is crucial - it allows higher-level code to handle the error appropriately for the user interface. This function handles logging and classification, but the UI layer handles user communication.

This pattern creates a clear separation of concerns:
1. **This function**: Validates data, attempts storage, logs errors with context
2. **Calling function**: Handles user interface updates, retry logic, fallback behaviors

**Best practices demonstrated**:
- Log errors with as much context as possible
- Use error properties (field, operation) to provide specific information
- Always re-throw unless you're at the final handling layer
- Handle expected error types explicitly, with fallback for unexpected ones

In a complete implementation, the storage operations would also throw HabitStorageError when database operations fail, maintaining consistency throughout the error handling system.

This layered approach makes debugging much easier - logs tell you exactly what failed and where, while the UI gets appropriate error information for user communication.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Error Handling Do's ‚úÖ

- Use specific error types for different failures
- Provide helpful error messages for debugging
- Log errors with context for troubleshooting
- Implement retry logic for transient failures
- Show user-friendly messages

<Notes>
These are the fundamental principles that separate professional error handling from amateur approaches. Let's break down each best practice:

**Use specific error types for different failures**: Instead of throwing generic Error objects, create custom error classes like ValidationError, NetworkError, or StorageError. This allows your error handling code to respond appropriately to different problems. In our habit tracker, a validation error might highlight form fields, while a network error might show a retry button.

**Provide helpful error messages for debugging**: Error messages should include enough context for developers to understand what went wrong and why. "Failed to save habit 'Exercise' to database: connection timeout after 5000ms" is much more helpful than "Database error". Include relevant values, operation names, and specific failure reasons.

**Log errors with context for troubleshooting**: When logging errors, include information about what the user was trying to do, their session state, browser information, and the sequence of events that led to the error. This context is invaluable when debugging production issues.

**Implement retry logic for transient failures**: Many errors are temporary - network timeouts, server overload, or resource locks. Implement automatic retry with exponential backoff for these cases. In our habit tracker, if syncing fails due to a network error, retry after 1 second, then 2 seconds, then 4 seconds before giving up.

**Show user-friendly messages**: Users shouldn't see technical error messages or stack traces. Translate technical errors into language users can understand and act upon. "Your internet connection seems unstable. We've saved your changes locally and will sync them when connection is restored."

These practices work together to create robust applications that handle failures gracefully while providing excellent debugging information for developers.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## Error Handling Don'ts ‚ùå

- Don't swallow errors silently
- Don't expose sensitive info in error messages
- Don't retry non-recoverable errors
- Don't use generic catch-all handlers everywhere

<Notes>
These anti-patterns are common mistakes that can make debugging nightmarish and create security vulnerabilities. Let's examine each one:

**Don't swallow errors silently**: Never write `try { riskyOperation(); } catch (error) { /* do nothing */ }`. Silent failures are debugging nightmares - something is broken but there's no indication what or where. At minimum, log the error. Better yet, handle it appropriately or let it bubble up to code that can handle it properly.

**Don't expose sensitive info in error messages**: Error messages shown to users should never contain passwords, API keys, internal server paths, database schemas, or other sensitive information. In our habit tracker, don't show "Failed to connect to database at 192.168.1.100:3306 with user 'admin'" - show "Unable to save your data right now" instead.

**Don't retry non-recoverable errors**: Some errors are permanent and retrying them is pointless or harmful. Don't retry authorization failures (the user needs to log in), validation errors (the data is fundamentally wrong), or quota exceeded errors (retrying will just hit the same limit). Only retry transient failures like network timeouts or server overload.

**Don't use generic catch-all handlers everywhere**: While having a final catch-all is good practice, don't rely on them for normal error handling. `catch (error) { showGenericError(); }` everywhere means you're not providing specific, helpful error handling. Use specific error types and handle them appropriately before falling back to generic handlers.

Common example of what NOT to do:
```javascript
try {
  // complex operation
} catch (error) {
  // BAD: swallowing error silently
}
```

These anti-patterns make applications unreliable, insecure, and difficult to maintain. Following the "do's" while avoiding these "don'ts" leads to robust, professional error handling.
</Notes>
</SlideLayout.Full>

<SlideLayout.Full>
## üéØ Key Takeaways: Error Handling

1. **Use try/catch/finally** for error-prone operations
2. **Create custom error classes** for different scenarios
3. **Make errors recoverable** when appropriate
4. **Log errors with context** for debugging
5. **Show user-friendly messages** not technical details

### Coming Up Next: Advanced Functions
Closures, higher-order functions, and functional programming!

<Notes>
Let's wrap up with the most important concepts from this error handling session. These five principles will serve you well in any JavaScript application:

**1. Use try/catch/finally for error-prone operations**: Any operation that could fail - file I/O, network requests, JSON parsing, database operations - should be wrapped in try/catch blocks. Use finally for cleanup operations that must run regardless of success or failure.

**2. Create custom error classes for different scenarios**: Don't rely on generic Error objects. Create specific error types like ValidationError, NetworkError, and StorageError. This enables sophisticated error handling that can respond appropriately to different failure modes.

**3. Make errors recoverable when appropriate**: Not all errors are fatal. Network failures can be retried, validation errors can prompt user corrections, and storage failures might fall back to alternative storage methods. Design your applications to gracefully handle and recover from expected failures.

**4. Log errors with context for debugging**: When errors occur, log comprehensive information including what the user was doing, the application state, and environmental factors. This context is invaluable for reproducing and fixing production issues.

**5. Show user-friendly messages not technical details**: Users don't need to see stack traces or technical error codes. Translate technical errors into understandable language and provide actionable guidance when possible.

In our habit tracker context, this means:
- Graceful handling of invalid form inputs with specific field feedback
- Offline functionality when network sync fails
- Clear user communication about what went wrong and how to fix it
- Comprehensive logging for production debugging

**Coming up next**: We'll explore advanced functions including closures, higher-order functions, and functional programming patterns. These concepts build on the error handling foundation we've established and are essential for writing sophisticated JavaScript applications.
</Notes>
</SlideLayout.Full>